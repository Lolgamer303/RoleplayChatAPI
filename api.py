# The comments of this file were generated by AI.

# This is the backend of roleplaychat, a web application that allows users to create and manage campaigns for role-playing games.
# The application uses Flask for the backend, SQLAlchemy for database interactions, and Google GenAI for generating content.
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from google import genai
from google.genai import types
from sqlalchemy import text
from sqlalchemy.orm import Session
from functools import wraps
import uuid
import os
from datetime import timedelta

app = Flask(__name__)

# ENV CONFIG
API_KEY = os.environ.get('API_KEY')
DATABASE_URL = os.environ.get('DATABASE_URL')
if not API_KEY:
    raise ValueError("No API_KEY found for Flask application")  # Ensure API_KEY is set in the environment
if not DATABASE_URL:
    raise ValueError("No DATABASE_URL found for Flask application")  # Ensure DATABASE_URL is set in the environment

app.config['SQLALCHEMY_DATABASE_URI'] = DATABASE_URL
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

# GENAI CLIENT SETUP
client = genai.Client(api_key=API_KEY)

# Load the default prompt from a file to initialize the AI model's context
with open('default_prompt.txt', 'r') as file:
    default_prompt = file.read()

# Base context for AI interactions, used to maintain consistent behavior
base_context = [
    types.Content(role='user', parts=[types.Part(text=default_prompt)]),
    types.Content(role='model', parts=[types.Part(text='Understood')]),
    types.Content(role='user', parts=[types.Part(text='start')]),
]

# --- API KEY AUTH (NOW FROM HEADER) ---
def verify_api_key():
    """
    Verifies the API key provided in the Authorization header.
    Returns the API key ID if valid, or an error message if invalid.
    """
    auth_header = request.headers.get('Authorization')
    if not auth_header:
        return None, "Missing Authorization header."

    if not auth_header.startswith('Bearer '):
        return None, "Invalid Authorization header format."

    api_key = auth_header.replace('Bearer ', '').strip()

    try:
        # Query the database to check if the API key exists
        with Session(db.engine) as session:
            result = session.execute(
                text("""SELECT id FROM "ApiKey" WHERE key = :key"""),
                {'key': api_key}
            ).fetchone()
            if not result:
                return None, "Invalid API key."
            return result[0], None
    except Exception as e:
        return None, f"Database error: {e}"
    
# --- DECORATORS ---
def require_api_key(f):
    """
    Decorator to enforce API key authentication for routes.
    Attaches the API key ID to the request context if valid.
    """
    @wraps(f)
    def decorated(*args, **kwargs):
        api_key_id, error = verify_api_key()
        if error:
            return jsonify({'error': error}), 401
        request.api_key_id = api_key_id  # Attach API key ID to the request context
        return f(*args, **kwargs)
    return decorated

def require_campaign(f):
    """
    Decorator to enforce campaign ownership validation for routes.
    Ensures the campaign belongs to the authenticated API key.
    """
    @wraps(f)
    def decorated(*args, **kwargs):
        api_key_id = request.api_key_id
        if not api_key_id:
            return jsonify({'error': 'API key is required.'}), 401
        campaign_id = kwargs.get('campaignid')
        if not campaign_id:
            return jsonify({'error': 'Campaign ID is required.'}), 400
        try:
            # Query the database to check if the campaign exists and belongs to the API key
            with Session(db.engine) as session:
                result = session.execute(
                    text("""SELECT "apiKeyId" FROM "Campaign" WHERE id = :campaignid"""),
                    {'campaignid': str(campaign_id)}
                ).fetchone()
                if not result:
                    return jsonify({'error': 'Campaign not found.'}), 404
                if result[0] != api_key_id:
                    return jsonify({'error': 'You do not have access'}), 401
        except Exception as e:
            return jsonify({'error': f"Database error: {e}"}), 500

        return f(*args, **kwargs)
    return decorated

# --- DATABASE STORE FUNCTIONS ---

def storeChat(campaign_id, user_input, response):
    """
    Stores a chat message and its response in the database.
    Ensures the campaign exists before inserting the chat.
    """
    try:
        with Session(db.engine) as session:
            # Check if the campaign exists
            result = session.execute(
                text("""SELECT id FROM "Campaign" WHERE id = :campaign_id"""),
                {'campaign_id': str(campaign_id)}
            ).fetchone()
            if not result:
                return jsonify({'error': 'Campaign not found.'}), 404
            # Insert the new chat into the "Chat" table
            new_chat = {
                'message': user_input,
                'response': response,
                'campaignId': campaign_id
            }
            session.execute(
                text("""INSERT INTO "Chat" (message, response, "campaignId") 
                        VALUES (:message, :response, :campaignId)"""),
                new_chat
            )
            session.commit()
            return jsonify({'success': 'Chat stored successfully.'}), 201
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def storeSummary(campaign_id, summary):
    """
    Stores a summary of chat messages in the database.
    Deletes older messages to maintain a manageable chat history.
    """
    try:
        with Session(db.engine) as session:
            # Fetch the timestamp of the second message in the campaign
            second_message_timestamp_result = session.execute(
                text("""
                    SELECT "createdAt"
                    FROM "Chat"
                    WHERE "campaignId" = :campaign_id
                    ORDER BY "createdAt" ASC
                    OFFSET 1 
                    LIMIT 1
                """),
                {'campaign_id': str(campaign_id)}
            ).fetchone()
            if not second_message_timestamp_result:
                return jsonify({'error': 'No messages found for the campaign.'}), 404
            second_message_timestamp = second_message_timestamp_result[0]

            # Delete older messages beyond a certain limit
            session.execute(
                text("""
                    DELETE FROM "Chat"
                    WHERE "campaignId" = :campaign_id
                    AND id IN (
                        SELECT id FROM "Chat"
                        WHERE "campaignId" = :campaign_id
                        ORDER BY "createdAt" ASC
                        OFFSET 2
                        LIMIT 5
                    )
                """),
                {'campaign_id': str(campaign_id)}
            )

            # Insert the summary as a new chat message
            session.execute(
                text("""
                    INSERT INTO "Chat" (message, response, "campaignId", "createdAt")
                    VALUES (:message, :response, :campaignId, :createdAt)
                """),
                {
                    'message': 'This is a summary of the previous messages, used to keep the chat history manageable :',
                    'response': summary,
                    'campaignId': str(campaign_id),
                    'createdAt': second_message_timestamp + timedelta(seconds=1)  # Add a small offset
                }
            )
            session.commit()
            return jsonify({'success': 'Summary stored successfully.'}), 201
    except Exception as e:
        print(e)
        return jsonify({'error': str(e)}), 500

# --- ROUTES ---

@app.route('/campaigns', methods=['GET'])
@require_api_key
def get_campaigns():
    """
    Retrieves all campaigns associated with the authenticated API key.
    Optionally filters by user ID if provided.
    """
    api_key_id = request.api_key_id
    userId = request.args.get('userId', None)
    try:
        with Session(db.engine) as session:
            if userId:
                # Fetch campaigns for the specific user
                result = session.execute(
                    text("""SELECT id, name FROM "Campaign" WHERE "apiKeyId" = :id AND "userId" = :userId"""),
                    {'id': api_key_id, 'userId': userId}
                ).fetchall()
            else:
                # Fetch all campaigns for the API key
                result = session.execute(
                    text("""SELECT id, name FROM "Campaign" WHERE "apiKeyId" = :id"""),
                    {'id': api_key_id}
                ).fetchall()
            # Convert the query result into a list of dictionaries for JSON response
            campaigns = [{'id': str(row[0]), 'name': row[1]} for row in result]
    except Exception as e:
        print(f"Error fetching campaigns: {e}")
        return jsonify({'error': f"Database error: {e}"}), 500

    if len(campaigns) == 0: 
        # Return a 204 status if no campaigns are found
        return jsonify({'message': 'You have no campaigns yet.'}), 204
    return jsonify(campaigns)

@app.route('/campaigns', methods=['POST'])
@require_api_key
def create_campaign():
    """
    Creates a new campaign for the authenticated API key.
    Initializes the campaign with a default prompt and stores it in the database.
    """
    
    api_key_id = request.api_key_id
    name = request.json.get('name', '')
    book = request.json.get('book', '')
    prompt = request.json.get('prompt', default_prompt)  # Use default prompt if none is provided
    userId = request.json.get('userId', None)

    if not name or not book or not prompt:
        # Ensure all required fields are provided
        return jsonify({'error': 'Missing required fields.'}), 400

    try:
        with Session(db.engine) as session:
            # Prepare the new campaign data
            new_campaign = {
                'id': str(uuid.uuid4()),  # Generate a unique ID for the campaign
                'name': name,
                'book': book,
                'prompt': prompt,
                'userId': userId,
                'apiKeyId': api_key_id
            }
            # Insert the new campaign into the database
            session.execute(
                text("""INSERT INTO "Campaign" (id, name, book, prompt, "userId", "apiKeyId") 
                        VALUES (:id, :name, :book, :prompt, :userId, :apiKeyId)"""),
                new_campaign
            )
            # Add the default prompt as the first chat message
            session.execute(
                text("""INSERT INTO "Chat" (message, response, "campaignId") 
                        VALUES (:message, :response, :campaignId)"""),
                {
                    'message': default_prompt,
                    'response': 'Understood',
                    'campaignId': new_campaign['id']
                }
            )
            session.commit()

            # Generate an initial AI response for the campaign
            response = client.models.generate_content(
                model='gemini-2.0-flash', contents=base_context
            )
            # Store the AI response in the chat history
            session.execute(
                text("""INSERT INTO "Chat" (message, response, "campaignId") 
                        VALUES (:message, :response, :campaignId)"""),
                {
                    'message': '',
                    'response': response.text,
                    'campaignId': new_campaign['id']
                }
            )
            session.commit()
    except Exception as e:
        print(f"Error creating campaign: {e}")
        return jsonify({'error': f"Database error: {e}"}), 500
    
    return jsonify({'status': 'success', 'message': 'Campaign created successfully.'}), 201

@app.route('/campaigns/<uuid:campaignid>', methods=['GET'])
@require_api_key
def get_campaign_info(campaignid):
    """
    Retrieves detailed information about a specific campaign.
    Ensures the campaign belongs to the authenticated API key.
    """
    api_key_id = request.api_key_id
    try: 
        with Session(db.engine) as session:
            # Query the campaign details from the database
            result = session.execute(
                text("""SELECT "apiKeyId", book, prompt, name, "createdAt" FROM "Campaign" WHERE id = :campaignid"""),
                {'campaignid': str(campaignid)}
            ).fetchone()
            if not result:
                # Return 404 if the campaign is not found
                return jsonify({'error': 'Campaign not found.'}), 404
            if result[0] != api_key_id:
                # Return 401 if the campaign does not belong to the API key
                return jsonify({'error': 'You do not have access'}), 401
            # Return the campaign details as JSON
            return jsonify({
                'book': result[1],
                'prompt': result[2],
                'name': result[3],
                'created_at': result[4]
            })
    except Exception as e:
        return jsonify({'error': f"Database error: {e}"}), 500
    
@app.route('/campaigns/<uuid:campaignid>', methods=['PUT'])
@require_api_key
@require_campaign
def edit_campaign_info(campaignid):
    """
    Updates the name of a specific campaign.
    Ensures the campaign belongs to the authenticated API key.
    """
    name = request.json.get('name', None)
    try:
        with Session(db.engine) as session:
            if name:
                # Update the campaign name in the database
                session.execute(
                    text("""UPDATE "Campaign" SET name = :name WHERE id = :campaignid"""),
                    {'name': name, 'campaignid': str(campaignid)}
                )
                session.commit()
    except Exception as e:
        return jsonify({'error': f"Database error: {e}"}), 500
    return jsonify({'status': 'success', 'message': 'Campaign updated successfully.'}), 200
    
@app.route('/campaigns/<uuid:campaignid>', methods=['DELETE'])
@require_api_key
@require_campaign
def delete_campaign(campaignid):
    """
    Deletes a specific campaign and its associated data.
    Ensures the campaign belongs to the authenticated API key.
    """
    try: 
        with Session(db.engine) as session:
            # Delete the campaign from the database
            session.execute(
                text("""DELETE FROM "Campaign" WHERE id = :campaignid"""),
                {'campaignid': str(campaignid)}
            )
            session.commit()
    except Exception as e:
        return jsonify({'error': f"Database error: {e}"}), 500
    
    return jsonify({'status': 'success', 'message': 'Campaign deleted successfully.'}), 200

@app.route('/campaigns/<uuid:campaignid>/chats', methods=['POST'])
@require_api_key
@require_campaign
def campaign_chat(campaignid):
    """
    Handles user input for a campaign and generates an AI response.
    Stores the chat history and manages chat summarization if needed.
    """
    user_input = request.json.get('input', '')
    print(f"User input: {user_input}")

    try:
        with Session(db.engine) as session:
            # Fetch the chat history for the campaign
            history_result = session.execute(
                text("""SELECT message, response FROM "Chat" WHERE "campaignId" = :campaignid ORDER BY "createdAt" DESC"""),
                {'campaignid': str(campaignid)}
            ).fetchall()

            if history_result and len(history_result) > 8:
                # Summarize older chat messages if the history exceeds 8 messages
                summary = client.models.generate_content(
                    model='gemini-2.0-flash', contents=[types.Content(role='user', parts=[types.Part(text=f"""
                    AI, please provide a detailed yet not too long summary of the messages provided below.
                    include all the important information in the summary.
                    provide the summary only, no introduction.
                    Do not include any other text than the summary itself and take part of the game master that talks. 
                    Write the text as if the user asked you a summary.
                    Describe the actions fully, both what the user choose to do and what happened aftewards. The messages are: {str(history_result[-6:-2])}. The summary is:
                    """)])])
                
                print(f"input : {history_result[-2:-6]}")  # Debugging: Print the input for summarization
                print(f"Summary: {summary.text}")  # Debugging: Print the generated summary
                storeSummary(campaignid, summary.text)
            if not history_result:
                # Use the base context if no chat history exists
                history = base_context
            else:
                # Convert the chat history into the required format for the AI model
                history = [
                    types.Content(role='user', parts=[types.Part(text=row[0])]) if i % 2 == 0 else
                    types.Content(role='model', parts=[types.Part(text=row[1])])
                    for i, row in enumerate(reversed(history_result))
                ]
            # Generate an AI response based on the chat history and user input
            response = client.models.generate_content(
                model='gemini-2.0-flash', contents=history + ([types.Content(role='user', parts=[types.Part(text=user_input)])] if history_result else None)
            )
            # Store the user input and AI response in the database
            storeChat(campaignid, user_input, response.text)
            return jsonify({'response': response.text})

    except Exception as e:
        print(f"Error in campaign_chat: {e}")
        return jsonify({'error': f"Database error: {e}"}), 500

@app.route('/campaigns/<uuid:campaignid>/chats', methods=['GET'])
@require_api_key
@require_campaign
def get_chats(campaignid):
    number = request.args.get('number', None)
    try: 
        with Session(db.engine) as session:
            if number:
                result = session.execute(
                    text("""SELECT message, response, "createdAt" FROM "Chat" WHERE "campaignId" = :campaignid ORDER BY "createdAt" ASC LIMIT :number"""),
                    {'campaignid': str(campaignid), 'number': number}
                ).fetchall()
            else:
                result = session.execute(
                    text("""SELECT message, response, "createdAt" FROM "Chat" WHERE "campaignId" = :campaignid ORDER BY "createdAt" ASC"""),
                    {'campaignid': str(campaignid)}
                ).fetchall()
            chats = [{'message': row[0], 'response': row[1], 'createdAt': row[2]} for row in result]
    except Exception as e:
        return jsonify({'error': f"Database error: {e}"}), 500

    if len(chats) == 0: return jsonify({'message': 'No chats found for this campaign.'}), 204
    return jsonify(chats)

@app.route('/campaigns/<uuid:campaignid>/chats', methods=['DELETE'])
@require_api_key
@require_campaign
def delete_chats(campaignid):
    number = request.args.get('count', None, type=int)
    try:
        with Session(db.engine) as session:
            if number:
                session.execute(
                    text("""
                        DELETE FROM "Chat"
                        WHERE id IN (
                            SELECT id FROM "Chat"
                            WHERE "campaignId" = :campaignid
                            ORDER BY "createdAt" DESC
                            LIMIT :number
                        )
                    """),
                    {'campaignid': str(campaignid), 'number': number}
                )
            else:
                session.execute(
                    text("""DELETE FROM "Chat" WHERE "campaignId" = :campaignid"""),
                    {'campaignid': str(campaignid)}
                )
                session.execute(
                    text("""INSERT INTO "Chat" (message, response, "campaignId") 
                            VALUES (:message, :response, :campaignId)"""),
                    {
                        'message': default_prompt,
                        'response': 'Understood',
                        'campaignId': str(campaignid)
                    }
                )

            session.commit()
    except Exception as e:
        return jsonify({'error': f"Database error: {e}"}), 500
    return jsonify({'status': 'success', 'message': 'Chats deleted and history reset successfully.'}), 200
    
# --- START ---
if __name__ == '__main__':
    app.run(debug=True)